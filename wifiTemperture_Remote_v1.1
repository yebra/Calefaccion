

/**  *
  WIFI MANAGER

  1. Versión
  Autor: Alberto Yebra
  Abril 2020
  Descripción:
  Sistema de calefacción encargado de:
  1- PANTALLA OLED con informacion de Temperatura
  2- Sensor de TEMPERATURA

  Todo sobre el ESP8266


  WifiManager
  Conexión con Alexa
  Conexión a sensor DHT temperatura

  Versión 1.0

  1.1  Change Wifimanage library becasue solve problem when wifi switch off and system was not recovering properly after serveral hours without Router AP Wifi signal




  nota compilar con la opción
  auxmoESP 3.X.X: When using Arduino Core for ESP8266 v2.4.X, double check you are building the project with LwIP Variant set to "v1.4 Higher Bandwidth".
* */


#define __DEBUG__ 1
//Librerías para manejar WifiManager
////#include <ESP8266WiFi.h>
#include <DNSServer.h>
////#include <ESP8266WebServer.h >
////#include <WiFiManager.h>
///Librería para el parapadeo del led
#include <Ticker.h>
//Librería sensor de Temperatura DHT
#include "DHT.h"
//Librería Acceso a la EEPROM
#include <EEPROM.h>


#include <ESP8266WiFi.h>
#include <WiFiClient.h>
#include <ESP8266WiFiMulti.h> 
#include <ESP8266mDNS.h>
#include <ESP8266WebServer.h>   // Include the WebServer library

ESP8266WiFiMulti wifiMulti;     // Create an instance of the ESP8266WiFiMulti class, called 'wifiMulti'

ESP8266WebServer server(80);    // Create a webserver object that listens for HTTP request on port 80


// Replace with your network credentials (STATION)
const char* ssid = "MOVISTAR_A2A0";
const char* password = "BE54316C434112149380";




//AsyncWebServer server(80);
DNSServer dns;

#include <Adafruit_Sensor.h>
#include <SPI.h>
#include <Wire.h>

//PANTALLA OLED SSD1306
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

//Humedity PINES DHT22
#define DHTPIN 13 //(GPI1 13 - (D7) 
#define DHTTYPE DHT22


//OLED
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define OLED_RESET LED_BUILTIN
// Initialize the OLED display using Wire library
Adafruit_SSD1306  display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);  //D2=SDK  D1=SCK  As per labeling on NodeMCU

String webPage, notice;
//Variables que nos va a enviar el WifiManager para poder conocer cómo está configurado
int quemador = 3; //Valor 3 cuando no tenemos info
int calefaccion = 3;
int termostato = 3;

//Define la Struct que contiene la información que vamos a representar en la pantalla OLED
struct StructOLED {
  char cadenaTiempo[16];
  float temperatura;
  float consigna;
  boolean quemador;  //Indica si en estos momentos tenemos el quemador activado
  int Secuencia_Quemador; //Para realizar la animacion
  boolean termostato_pared; //Indica si el termostato de la pared está a ÓN

  boolean calefaccion; //Indica si tenemos la calefacción habilitada
  boolean mostrar_comunicacion; //Para indicar que hay un mensaje nuevo
  char comunicaciones[25]; //Informacion sobre el estado de las comunicaciones
};


StructOLED DatosOLED;




/**const char htmlPage[]PROGMEM=R"=====(
  <!DOCTYPE html>
  <html>
  <body>
  <h3>Electronic Notice Board </h3>
  <FORM METHOD="POST"action="/postForm">
  <input type="text" name="myText" value="Write your Consigna...">
  <input type="submit" value="Post Notice">
  </form>
  </body>
  </html>
  )=====";
**/

const String htmlPage = "<html>\
  <head>\
    <title>ESP8266 Web Server POST handling</title>\
    <style>\
      body { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\
    </style>\
  </head>\
  <body>\
    <h1>POST plain text to /postplain/</h1><br>\
    <form method=\"post\" enctype=\"text/plain\" action=\"/postplain/\">\
      <input type=\"text\" name=\'{\"hello\": \"world\", \"trash\": \"\' value=\'\"}\'><br>\
      <input type=\"submit\" value=\"Submit\">\
    </form>\
    <h1>POST form data to /postform/</h1><br>\
    <form method=\"post\" enctype=\"application/x-www-form-urlencoded\" action=\"/postform/\">\
      <input type=\"text\" name=\"hello\" value=\"world\"><br>\
      <input type=\"submit\" value=\"Submit\">\
    </form>\
  </body>\
</html>";


// Temporizador
unsigned long marcaTiempoDate = 0;
unsigned long tiempoRefreshDate = 1000;

// Variables almacena tiempo millis
int dias;
int horas;
int minutos;
int segundos;

// Cadena para almacenar texto formateado
char cadenaTiempo[16];

// Variable para recibir cuando se recibe peticiones http y mostrar en display que tiene comunicación
boolean estado_comunicacion;


// Server listen in 80 port
////ESP8266WebServer server(80);
//WiFiServer server(80);
// Create AsyncWebServer object on port 80
//AsyncWebServer server(80);



DHT dht(DHTPIN, DHTTYPE);
////WiFiClient espClient;


//Variables información temporal
long lastMsg = 0;
char msg[50];
int value = 0;


//IP address by default when you have connected to network
IPAddress local_IP(192, 168, 1, 5);
IPAddress gateway(192, 168, 1, 1);
IPAddress subnet(255, 255, 255, 0);


Ticker ticker;

// Pin LED azul
byte pinLed = 4;

//to take information about temperture and humedity
float h ;
float t ;




#define LOGO_HEIGHT   16
#define LOGO_WIDTH    16


static const unsigned char PROGMEM logo_bmp[] =
{ B00000000, B11000000,
  B00000001, B11000000,
  B00000001, B11000000,
  B00000011, B11100000,
  B11110011, B11100000,
  B11111110, B11111000,
  B01111110, B11111111,
  B00110011, B10011111,
  B00011111, B11111100,
  B00001101, B01110000,
  B00011011, B10100000,
  B00111111, B11100000,
  B00111111, B11110000,
  B01111100, B11110000,
  B01110000, B01110000,
  B00000000, B00110000
};

static const unsigned char PROGMEM image_portada[8192] = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0xff, 0xf3, 0xfe, 0x3f, 0xff, 0xf9, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x38, 0x01, 0xf8, 0xff, 0x9f, 0xff, 0xfc, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xfc, 0x7c, 0x1f, 0x8f, 0xff, 0xfe, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0x3f, 0x0f, 0xc7, 0xff, 0xfe, 0x7f, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xdf, 0x8f, 0xe7, 0xff, 0xff, 0x3f, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xbf, 0xfe, 0xef, 0xcf, 0xf3, 0xff, 0xff, 0xbf, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xbf, 0xfe, 0xe7, 0xc7, 0xf9, 0xff, 0xff, 0x9f, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xbf, 0xfe, 0xf7, 0xe7, 0xf8, 0xff, 0xff, 0xdf, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xbf, 0xfe, 0xf7, 0xe7, 0xf8, 0xff, 0xff, 0xcf, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xf7, 0xe7, 0xfc, 0xff, 0xff, 0xef, 0xff, 0xff,
  0xff, 0xff, 0xfe, 0x3f, 0xff, 0xfb, 0xff, 0xff, 0xe7, 0xf7, 0xfe, 0xff, 0xff, 0xef, 0xff, 0xff,
  0xff, 0xff, 0xc0, 0xff, 0xff, 0xfb, 0xf7, 0xfb, 0xef, 0xf3, 0xfe, 0xff, 0xff, 0xef, 0xff, 0xff,
  0xff, 0xff, 0x1f, 0xff, 0xff, 0xfd, 0xf1, 0xf3, 0xdf, 0xfb, 0xff, 0x7f, 0xff, 0xef, 0xff, 0xff,
  0xff, 0xfe, 0x7f, 0xc1, 0xff, 0xfe, 0xfc, 0x07, 0x9f, 0xfb, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xfe, 0xff, 0x1f, 0xff, 0xff, 0x1f, 0xfe, 0x7f, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xfc, 0xfe, 0xff, 0x9f, 0xff, 0xcf, 0xfc, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xfd, 0xfd, 0xf9, 0x9f, 0xff, 0xf3, 0xf9, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfd, 0xf3, 0x0f, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xef, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xf8, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfb, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfb, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfb, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfb, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xf9, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfd, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfd, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfd, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xf9, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfb, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfb, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfb, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfb, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfb, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xf3, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xf7, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xc7, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xdf, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

static const unsigned char PROGMEM image_data_CalefaccionOFF[1024] = {
  0x01, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x0f, 0xf0, 0x1f, 0xc3, 0xf8,
  0x01, 0x00, 0x02, 0x0f, 0xf0, 0x1f, 0xc3, 0xf8, 0x01, 0x00, 0x02, 0x30, 0x0c, 0x60, 0x0c, 0x00,
  0x01, 0x00, 0x02, 0x30, 0x0c, 0x60, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x30, 0x0c, 0x60, 0x0c, 0x00,
  0x01, 0x00, 0x02, 0x30, 0x0c, 0x60, 0x0c, 0x00, 0x01, 0xff, 0xfe, 0x30, 0x0c, 0x7f, 0xcf, 0xf8,
  0x01, 0xff, 0xfe, 0x30, 0x0c, 0x7f, 0xcf, 0xf8, 0x01, 0x00, 0x02, 0x30, 0x0c, 0x60, 0x0c, 0x00,
  0x01, 0x7f, 0xfa, 0x30, 0x0c, 0x60, 0x0c, 0x00, 0x01, 0x7f, 0xfa, 0x30, 0x0c, 0x60, 0x0c, 0x00,
  0x01, 0x7f, 0xfa, 0x30, 0x0c, 0x60, 0x0c, 0x00, 0x01, 0x7f, 0xfa, 0x0f, 0xf0, 0x60, 0x0c, 0x00,
  0x01, 0x00, 0x02, 0x0f, 0xf0, 0x60, 0x0c, 0x00, 0x01, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const unsigned char PROGMEM image_data_CalefaccionON[1024] = {
  0x01, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x03, 0xfc, 0x0c, 0x00, 0xc0,
  0x01, 0x7f, 0xfa, 0x03, 0xfc, 0x0c, 0x00, 0xc0, 0x01, 0x7f, 0xfa, 0x0c, 0x03, 0x0f, 0x00, 0xc0,
  0x01, 0x7f, 0xfa, 0x0c, 0x03, 0x0f, 0x00, 0xc0, 0x01, 0x7f, 0xfa, 0x0c, 0x03, 0x0c, 0xc0, 0xc0,
  0x01, 0x00, 0x02, 0x0c, 0x03, 0x0c, 0xc0, 0xc0, 0x01, 0xff, 0xfe, 0x0c, 0x03, 0x0c, 0x30, 0xc0,
  0x01, 0xff, 0xfe, 0x0c, 0x03, 0x0c, 0x30, 0xc0, 0x01, 0x00, 0x02, 0x0c, 0x03, 0x0c, 0x0c, 0xc0,
  0x01, 0x00, 0x02, 0x0c, 0x03, 0x0c, 0x0c, 0xc0, 0x01, 0x00, 0x02, 0x0c, 0x03, 0x0c, 0x03, 0xc0,
  0x01, 0x00, 0x02, 0x0c, 0x03, 0x0c, 0x03, 0xc0, 0x01, 0x00, 0x02, 0x03, 0xfc, 0x0c, 0x00, 0xc0,
  0x01, 0x00, 0x02, 0x03, 0xfc, 0x0c, 0x00, 0xc0, 0x01, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const unsigned char PROGMEM image_data_Quemador1[1024] = {
  0x00, 0x00, 0xfc, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x3f, 0x73, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x81, 0x61, 0x41, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x61, 0xc1, 0x40, 0xa3, 0x00, 0x00,
  0x00, 0x06, 0x60, 0x01, 0xc0, 0xe0, 0xc0, 0x00, 0x00, 0x05, 0xc0, 0x00, 0x00, 0x00, 0x40, 0x00,
  0x00, 0x06, 0x01, 0x80, 0x0c, 0x80, 0x40, 0x00, 0x00, 0x03, 0xc3, 0xc4, 0x3d, 0xf0, 0x40, 0x00,
  0x00, 0x00, 0xc1, 0xcc, 0x3f, 0xf1, 0xc0, 0x00, 0x00, 0x00, 0xc1, 0xfb, 0xff, 0xc3, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0x01, 0xef, 0x02, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0xc3, 0x1e, 0x00, 0x00,
  0x00, 0x00, 0x30, 0x30, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0xe0, 0xc0, 0x00, 0x00,
  0x00, 0x00, 0x1f, 0xed, 0xa1, 0x80, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc7, 0x1f, 0x00, 0x00, 0x00
};
static const unsigned char PROGMEM image_data_Quemador2[1024] = {
  0x00, 0x00, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x03, 0xf0, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x90, 0x73, 0x70, 0x07, 0x80, 0x00, 0x00, 0x06, 0x70, 0xd1, 0x78, 0x07, 0x80, 0x00,
  0x00, 0x06, 0x78, 0x93, 0xcc, 0x05, 0x80, 0x00, 0x00, 0x05, 0xc8, 0xb6, 0x0c, 0x1c, 0x80, 0x00,
  0x00, 0x06, 0x0c, 0xb4, 0x04, 0xb1, 0x80, 0x00, 0x00, 0x03, 0xcf, 0xdc, 0x35, 0xb1, 0x80, 0x00,
  0x00, 0x00, 0xce, 0x8c, 0x3f, 0xfb, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x70, 0x7c, 0x27, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0x00, 0x29, 0xcf, 0x00, 0x00, 0x00, 0x01, 0x87, 0xc0, 0x07, 0xfe, 0x00, 0x00,
  0x00, 0x03, 0x0c, 0x30, 0x0d, 0xe0, 0x00, 0x00, 0x00, 0x02, 0x0c, 0x38, 0xf8, 0x00, 0x00, 0x00,
  0x00, 0x03, 0xef, 0xed, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc7, 0x00, 0x00, 0x00, 0x00
};

static const unsigned char PROGMEM   image_data_TermostatoPared [] = {
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
  0x10, 0xf8, 0x04, 0x70, 0x00, 0x3f, 0xf8, 0x04, 0x10, 0x04, 0x04, 0x50, 0x00, 0x40, 0x04, 0x04,
  0x10, 0x04, 0x04, 0x70, 0x00, 0x43, 0x84, 0x04, 0x10, 0x04, 0x04, 0x00, 0x00, 0x40, 0x04, 0x04,
  0x10, 0x04, 0x04, 0x00, 0x00, 0x7f, 0xfc, 0x04, 0x10, 0x78, 0x00, 0x00, 0x00, 0x40, 0x04, 0x04,
  0x10, 0x80, 0x04, 0x00, 0x00, 0x40, 0x04, 0x04, 0x10, 0x80, 0x04, 0x00, 0x00, 0x41, 0x04, 0x04,
  0x10, 0x80, 0x04, 0x00, 0x00, 0x43, 0x84, 0x04, 0x10, 0x80, 0x04, 0x00, 0x00, 0x41, 0x04, 0x04,
  0x10, 0x7c, 0x04, 0x00, 0x00, 0x40, 0x04, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x04,
  0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc
};

void setup()
{
  Serial.begin(115200);


#ifdef __DEBUG__
  Serial.println("Initializing OLED Display");
  Serial.begin(115200);
  Serial.println("");
#endif
  // Modo del pin
  pinMode(pinLed, OUTPUT);

  // Empezamos el temporizador que hará parpadear el LED
  ticker.attach(0.2, parpadeoLed);

  // Creamos una instancia de la clase WiFiManager
  ////WiFiManager wifiManager;

  ////wifiManager.setSTAStaticIPConfig(local_IP, gateway, subnet);

  // Cremos AP y portal cautivo y comprobamos si
  // se establece la conexión
  /**  if (!wifiManager.autoConnect("ESP8266Temp")) {
    #ifdef __DEBUG__
      Serial.println("Fallo en la conexión (timeout)");
    #endif
      ESP.reset();
      delay(1000);
    }
  */
  // Connect to Wi - Fi network with SSID and password
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.config(local_IP, gateway, subnet);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  // Print local IP address and start web server
  Serial.println("");
  Serial.println("WiFi connected.");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
  




#ifdef __DEBUG__
  Serial.println("Ya estás conectado");
#endif


  // Eliminamos el temporizador
  ticker.detach();

  // Apagamos el LED
  //digitalWrite(pinLed, HIGH);

  dht.begin();


  // Setting the ESP as an access point
#ifdef __DEBUG__
  Serial.print("Setting AP (Access Point)…");
#endif
  // Remove the password parameter, if you want the AP (Access Point) to be open



  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3C for 128x32
    Serial.println(F("SSD1306 allocation failed"));
    for (;;); // Don't proceed, loop forever
  }

  display.clearDisplay();
  display.invertDisplay(true);
  display.fillScreen(0);         //Limpiamos la pantalla
  display.drawBitmap(0, 0, image_portada, 128, 64, SSD1306_WHITE);
  display.display();
  delay(4000);


  //TEXTO CON FUENTE PREDETERMINADA
  display.invertDisplay(false);
  display.fillScreen(0);         //Limpiamos la pantalla

  display.setFont();             //Fuente por defecto -si no la hemos cambiado no es necesario seleccionarla

  display.setTextSize(1);
  display.setTextColor(1, 0);
  display.setCursor(0, 0);
  display.println("REMOTO - TE");
  display.setTextSize(2);
  display.print("IKER-ANDER");

  display.setTextSize(2);
  display.setTextColor(1, 0);    //Color invertido
  display.setCursor(0, 32);
  display.print("Iniciando...");
  display.display();             //Refrescamos la pantalla para visualizarlo
  Serial.println("Iniciando OLED");
  delay(4000);

  h = dht.readHumidity();
  t = dht.readTemperature();

  server.on("/", handleRoot);
  server.on("/temperature", handleTemperature);
  server.on("/humedity", handleHumedity);
  server.on("/consigna", handleConsigna);
  server.on("/setting", handleSetting);
  server.begin();
  Serial.println("HTTP server started");

}

void loop() {

  server.handleClient();


  // Protección overflow
  if (millis() < marcaTiempoDate) {
    marcaTiempoDate = millis();
  }

  // Comprobar is hay que actualizar temperatura
  if (millis() - marcaTiempoDate >= tiempoRefreshDate)
  {
    // Actualizar variables de tiempo
    millisToTiempo(millis());
    // Componer cadena con la información del tiempo formateada
    sprintf(cadenaTiempo, "%02d:%02d:%02d:%02d", dias, horas, minutos, segundos);

    // Marca de tiempo
    marcaTiempoDate = millis();
  }

  long now = millis();
  if (now - lastMsg > 4000) {
    lastMsg = now;
    ++value;
    //snprintf (msg, 75, "%d", t);
    h = dht.readHumidity();
    t = dht.readTemperature();
    if (isnan(h) || isnan(t)) {
      Serial.println("Error en la lectura del sensor!\n");
      return;
    }

    sprintf(DatosOLED.cadenaTiempo, cadenaTiempo);
    DatosOLED.temperatura = t;

    Serial.print(" Humedad: ");
    Serial.print(h);
    Serial.print(" %\t");
    Serial.print("Temperatura: ");
    Serial.print(t);
    Serial.print(" *C \n");
    display.display();
  }
  OLED_print();
  delay(2000);
}

/*
  Función que convierte millis() a segundos, minutos, horas y días
  Almacena la información en variables globales
*/
void millisToTiempo(unsigned long valMillis) {
  // Se obtienen los segundos
  valMillis = valMillis / 1000;

  segundos = valMillis % 60; // se divide entre segundos por minuto y te quedas con el resto
  minutos = valMillis / 60; // Se convierte a minutos
  minutos = minutos % 60; // se divide entre minutos por hora y te quedas con el resto
  horas = (valMillis / 60) / 60; // Se convierte en horas
  horas = horas % 24; // se divide entre horas al día y te quedas con el resto
  dias = ((valMillis / 60) / 60) / 24; // Se convierte en días
#ifdef __DEBUG__
  Serial.print("Segundos = ");
  Serial.println(valMillis);
  Serial.print(dias);
  Serial.print(":");
  Serial.print(horas);
  Serial.print(":");
  Serial.print(minutos);
  Serial.print(":");
  Serial.println(segundos);
#endif
}

void handleRoot() {
  //server.send(200, "text/plain", "Hello world!");   // Send HTTP status 200 (Ok) and send some text to the browser/client
  server.send_P(200, "text/plain", "Termostato Remoto Version 1.0");

#ifdef __DEBUG__
  Serial.println("Peticion! http\n");

#endif
}

void handleTemperature() {
  //server.send(200, "text/plain", "Hello world!");   // Send HTTP status 200 (Ok) and send some text to the browser/client


  String notice = server.arg("Status");
  String noticeC = "";
  String noticeQ = "";
  String noticeT = "";

  Serial.println("Peticion! http Temperture\n");

  noticeT  = notice.substring(0, 1);
  noticeC  = notice.substring(1, 2);
  noticeQ  = notice.substring(2, 3);


  Serial.println(noticeC);
  Serial.println(noticeT);
  Serial.println(noticeQ);

  if (noticeC.toInt() == 0) {
    //Calefaccion apagada
    DatosOLED.calefaccion = 0;
  } else {
    //Calefaccion encendida
    DatosOLED.calefaccion = 1;
  }

  if (noticeT.toInt()  == 0) {
    //termostato apagada
    DatosOLED.termostato_pared = 0;
  } else {
    //Calefaccion encendida
    DatosOLED.termostato_pared = 1;
  }


  if (noticeQ.toInt() == 0) {
    //Quemador apagada
    DatosOLED.quemador = 0;
  } else {
    //Quemador encendida
    DatosOLED.quemador = 1;
  }

  server.send_P(200, "text/plain", String(t, 3).c_str());
  OLED_parpadeo();
#ifdef __DEBUG__
  Serial.println("Peticion! http Tempertarua\n");
  Serial.println(String(t, 3).c_str());
  //Llamada a blink en OLED
#endif

}



void handleHumedity() {
  //server.send(200, "text/plain", "Hello world!");   // Send HTTP status 200 (Ok) and send some text to the browser/client
  server.send_P(200, "text/plain", String(h, 3).c_str());
#ifdef __DEBUG__
  Serial.println("Peticion! http Humedad\n");
  Serial.println(String(h, 3).c_str());
#endif
}
void handleSetting() {
  String value = server.arg("value"); //this lets you access a query param (http://x.x.x.x/setting?value=1)

  String noticeC = server.arg("Calefaccion");
  String noticeT = server.arg("Termostato");
  String noticeQ = server.arg("Quemador");

  Serial.println("Peticion! http Setting\n");
  Serial.println(noticeC);
  Serial.println(noticeT);
  Serial.println(noticeQ);



  if (noticeC.toInt() == 0) {
    //Calefaccion apagada
    DatosOLED.calefaccion = 0;
  } else {
    //Calefaccion encendida
    DatosOLED.calefaccion = 1;
  }

  if (noticeT.toInt()  == 0) {
    //termostato apagada
    DatosOLED.termostato_pared = 0;
  } else {
    //Calefaccion encendida
    DatosOLED.termostato_pared = 1;
  }


  if (noticeQ.toInt() == 0) {
    //Quemador apagada
    DatosOLED.quemador = 0;
  } else {
    //Quemador encendida
    DatosOLED.quemador = 1;
  }

  server.send_P(200, "text/plain", "OK");

}

void handleConsigna() {
  //Rutina para leer Consigna
  //server.send(200, "text/plain", "Hello world!");   // Send HTTP status 200 (Ok) and send some text to the browser/client
  //server.send_P(200, "text/plain", "Consigna");
  webPage = htmlPage;
  notice = server.arg("myText");
  Serial.println("Text Received, contents:");
  Serial.println(notice);
  server.send(200, "text/html", webPage);



#ifdef __DEBUG__
  Serial.println("Peticion! http Consigna\n");

#endif
}

void handleNotFound() {
  server.send(404, "text/plain", "404: Not found"); // Send HTTP status 404 (Not Found) when there's no handler for the URI in the request
}



//OLED function
void OLED_print() {

  Serial.print("\n OLED:Secuencia_QUEMADOR:");
  Serial.print(DatosOLED.Secuencia_Quemador);

  display.clearDisplay();
  display.fillScreen(0);         //Limpiamos la pantalla

  // Dibujar texto tiempo
  DatosOLED.Secuencia_Quemador = DatosOLED.Secuencia_Quemador + 1;

  //SE muestra el menaje una vez recibida una comunicación, después ya el funcionamiento de todo
  //Bloque 1
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.println(DatosOLED.cadenaTiempo);

  //Bloque 2
  display.setTextSize(2);
  display.setCursor(0, 16);
  display.println(DatosOLED.temperatura, 1);
  //display.cp437(true);
  //display.write(167);
  //display.println("C");

  // Bloque 3
  display.setTextSize(2);
  display.setCursor(70, 0);
  display.println(DatosOLED.consigna, 1);
  //display.cp437(true);
  //display.write(167);
  //display.println("C");

  // Bloque 4
  Serial.print("\n OLED:Quemador:");
  Serial.print(DatosOLED.quemador);

  if (DatosOLED.quemador == 1) {
    if (DatosOLED.Secuencia_Quemador == 1) {
      display.drawBitmap(64, 16, image_data_Quemador1, 64, 16, SSD1306_WHITE);
    } else {
      DatosOLED.Secuencia_Quemador = 0;
      display.drawBitmap(64, 16, image_data_Quemador2, 64, 16, SSD1306_WHITE);
    }
  }

  // Bloque 5
  //Serial.println("DatosOLED.termostato_pared");
  //Serial.println(DatosOLED.termostato_pared);

  //Serial.print("\n OLED:Termostato:");
  //Serial.print(DatosEE.E_Termostato);

  if (DatosOLED.termostato_pared == 1) {
    //display.fillCircle(16,48 , 8, SSD1306_WHITE);
    display.drawBitmap(0, 40, image_data_TermostatoPared, 64, 16, SSD1306_WHITE);
  }//else display.drawCircle(16, 48, 8, SSD1306_WHITE);

  // Bloque 6

  Serial.print("\n OLED:Calefaccion:");
  Serial.print(DatosOLED.calefaccion);

  if (DatosOLED.calefaccion == 1) {
    display.drawBitmap(64, 40, image_data_CalefaccionON, 64, 16, SSD1306_WHITE);
  } else display.drawBitmap(64, 40, image_data_CalefaccionOFF, 64, 16, SSD1306_WHITE);
  //display.drawCircle(96, 64, 8, SSD1306_WHITE);
  // Bloque 7
  display.setTextSize(1);
  display.setCursor(0, 56);
  display.println(DatosOLED.comunicaciones);
  //Limpiamos el buffer una vez mostrada una vez mostrada en el display
  sprintf(DatosOLED.comunicaciones, "");

  display.display();
}
void OLED_parpadeo() {
  //Función para mostrar un parpadeo en esquina derecha cuando se recibe un dato
  estado_comunicacion = !estado_comunicacion;
  if (estado_comunicacion = 1) {
    display.drawCircle(123, 5, 5, SSD1306_WHITE);
    display.fillCircle(123, 5, 5, SSD1306_WHITE);
  } else {
    display.drawCircle(123, 5, 5, SSD1306_WHITE);
  }
  display.display();

}


void parpadeoLed() {
  // Cambiar de estado el LED
  byte estado = digitalRead(pinLed);
  digitalWrite(pinLed, !estado);
}
